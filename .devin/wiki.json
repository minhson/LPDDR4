{
  "repo_notes": [
    {
      "content": "This repo is an LPDDR4 memory subsystem with four blocks: (A) LPDDR4 controller RTL (protocol IFs → arbitration/scheduling/bank machines → DFI adapter), (B) DDR PHY RTL in wav-lpddr-hw/ (DFI-facing + physical-layer timing/IO), (C) PHY init/training/config SW in wav-lpddr-sw/, and (D) external LPDDR4 DRAM devices. Treat wav-lpddr-hw/ and wav-lpddr-sw/ as vendored code inside this repo (NOT submodules). The wiki must explain end-to-end control/data paths across A↔B↔D and the SW control path C→B (and any C→A register programming)."
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "High-level intro and what problem this subsystem solves. Summarize the four blocks (controller RTL, PHY RTL, PHY SW, DRAM device) and what each is responsible for.",
      "page_notes": [
        {
          "content": "Include a short glossary: controller, DFI, PHY, training, LPDDR4 device, 4-phase."
        }
      ]
    },
    {
      "title": "Getting Started",
      "purpose": "How to build/sim/run basic tests. Point to the minimal steps to instantiate the controller+PHY and run a sanity read/write flow.",
      "page_notes": [
        {
          "content": "Prefer concrete entrypoints: top modules, build scripts, sim targets, and where to change key parameters (timing/config)."
        }
      ]
    },
    {
      "title": "System Architecture",
      "purpose": "Explain the overall end-to-end architecture from host transactions down to DRAM pins, including the PHY HW/SW and DFI boundary.",
      "page_notes": [
        {
          "content": "Generate 3 SMALL readable diagrams (not 1 giant graph): (1) End-to-end block diagram: Host/SoC → Controller → DFI → Wavious PHY → LPDDR4 DRAM. (2) Controller internal diagram: Protocol IFs → xbar → bank machines → scheduler/refresh → DFI adapter. (3) PHY HW/SW diagram: wav-lpddr-sw (init/training) → programs wav-lpddr-hw → drives DRAM signals. Keep labels short (<=4 words) and move details into bullets."
        }
      ]
    },
    {
      "title": "End-to-End Data and Command Flow",
      "purpose": "Trace one READ and one WRITE end-to-end: external interface → internal scheduling → DFI phases → PHY IO → DRAM → return data.",
      "parent": "System Architecture",
      "page_notes": [
        {
          "content": "Explicitly separate: command path (ACT/RD/WR/PRE/REF) vs data path (write data beats, read data return). Call out where timing constraints gate progress."
        }
      ]
    },
    {
      "title": "Memory Controller RTL Top",
      "purpose": "Document controller top-level modules and integration boundaries (mc_top/mc_core equivalents), including ports, clocks/resets, and how sub-blocks connect.",
      "parent": "System Architecture",
      "page_notes": [
        {
          "content": "Identify the controller entrypoint module(s) and list the major instantiated submodules and their responsibilities."
        }
      ]
    },
    {
      "title": "Protocol Interfaces",
      "purpose": "Explain how external masters connect: AHB/AXI/Wishbone/Native. Describe what each is used for and how each converts into internal requests.",
      "parent": "Memory Controller RTL Top",
      "page_notes": [
        {
          "content": "Organize as sections per interface; include a small table of: bus → width → purpose → conversion module."
        }
      ]
    },
    {
      "title": "DFI Interface",
      "purpose": "Explain DFI at the controller↔PHY boundary, including the 4-phase concept and which signals carry commands vs write/read data.",
      "parent": "System Architecture",
      "page_notes": [
        {
          "content": "Must tie DFI directly to wav-lpddr-hw implementation: what DFI signals/phases are consumed/produced by the PHY, what handshake/valid rules exist, and how command+data align."
        }
      ]
    },
    {
      "title": "DFI Adapter",
      "purpose": "Explain how internal controller commands are translated into DFI (phasing, packing, timing alignment), and how read/write data beats are handled.",
      "parent": "DFI Interface",
      "page_notes": [
        {
          "content": "Include one worked example: internal READ/WRITE → per-phase CA/cmd → wrdata/rddata timing relationship."
        }
      ]
    },
    {
      "title": "Scheduling and Bank Machines",
      "purpose": "Explain crossbar arbitration, per-bank state machines, row buffer policy, auto-precharge decisions, and global scheduling/turnaround.",
      "parent": "Memory Controller RTL Top",
      "page_notes": [
        {
          "content": "Prefer a single state-transition diagram for bank machine behavior and a short bullet list of enforced constraints (tRCD, tRP, tRAS, tWTR, etc.)."
        }
      ]
    },
    {
      "title": "Refresh and Timing Enforcement",
      "purpose": "Explain refresh behavior (tREFI/tRFC), how refresh interacts with banks/scheduler, and how timing counters prevent illegal command sequences.",
      "parent": "Memory Controller RTL Top",
      "page_notes": [
        {
          "content": "Include a short section: where timing parameters live (CSR/config) and which module consumes them."
        }
      ]
    },
    {
      "title": "Configuration and CSR Map",
      "purpose": "Document configuration registers (addresses/fields) and what they control (timing, refresh, bank machine knobs, PHY-related config if any).",
      "parent": "Memory Controller RTL Top",
      "page_notes": [
        {
          "content": "If registers are numerous, group into tables by function (timing, refresh, debug/status, init)."
        }
      ]
    },
    {
      "title": "DDR PHY Integration (Wavious)",
      "purpose": "Explain how controller connects to Wavious PHY and what each side guarantees: clocks/resets, DFI signals, IO timing responsibilities, bring-up sequence boundaries.",
      "parent": "System Architecture",
      "page_notes": [
        {
          "content": "Clearly define the contract: controller produces DFI; PHY consumes DFI and drives CA/DQ/DQS; PHY returns rddata/valid. Mention any init/training hooks that SW triggers."
        }
      ]
    },
    {
      "title": "Wavious PHY RTL (wav-lpddr-hw)",
      "purpose": "Document wav-lpddr-hw/: top module(s), internal blocks (DFI receiver, timing/IO drivers), and how they map to LPDDR4 pins.",
      "parent": "DDR PHY Integration (Wavious)",
      "page_notes": [
        {
          "content": "Start from the PHY top module(s). List key submodules: DFI interface, per-lane IO, CA/DQ/DQS handling, any calibration/training interfaces exposed upward."
        }
      ]
    },
    {
      "title": "Wavious PHY Software (wav-lpddr-sw)",
      "purpose": "Document wav-lpddr-sw/: initialization flow, training (write leveling/read training), and how it programs PHY registers (and any controller registers).",
      "parent": "DDR PHY Integration (Wavious)",
      "page_notes": [
        {
          "content": "Provide a step-by-step init/training sequence and the key register groups it touches. Show where SW runs (host CPU/firmware) and when it must execute relative to controller traffic."
        }
      ]
    },
    {
      "title": "LPDDR4 DRAM Device View",
      "purpose": "Explain DRAM organization and device-facing requirements: banks/rows/cols, command set expectations, and timing from the device perspective.",
      "parent": "System Architecture",
      "page_notes": [
        {
          "content": "Tie device requirements back to controller blocks (bank machines/refresh/timing) and PHY blocks (IO timing)."
        }
      ]
    },
    {
      "title": "Verification and Simulation",
      "purpose": "Explain verification structure: testbenches, models, how to run regression/smoke tests, and how to validate controller↔PHY integration.",
      "page_notes": [
        {
          "content": "Include recommended debug signals/log points at each boundary: protocol IF, internal commands, DFI, PHY IO, rddata return."
        }
      ]
    },
    {
      "title": "Repository Guide",
      "purpose": "Map repository directories to responsibilities: where controller RTL lives, where wav-lpddr-hw lives, where wav-lpddr-sw lives, where tests/docs live.",
      "page_notes": [
        {
          "content": "Add a short 'Where do I change X?' section: timing params, DFI width/phases, init flow, training knobs."
        }
      ]
    }
  ]
}